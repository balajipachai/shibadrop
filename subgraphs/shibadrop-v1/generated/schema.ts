// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  TypedMap,
  Entity,
  Value,
  ValueKind,
  store,
  Bytes,
  BigInt,
  BigDecimal,
} from "@graphprotocol/graph-ts";

export class AllowListUpdated extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save AllowListUpdated entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type AllowListUpdated must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("AllowListUpdated", id.toBytes().toHexString(), this);
    }
  }

  static loadInBlock(id: Bytes): AllowListUpdated | null {
    return changetype<AllowListUpdated | null>(
      store.get_in_block("AllowListUpdated", id.toHexString()),
    );
  }

  static load(id: Bytes): AllowListUpdated | null {
    return changetype<AllowListUpdated | null>(
      store.get("AllowListUpdated", id.toHexString()),
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get nftContract(): Bytes {
    let value = this.get("nftContract");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set nftContract(value: Bytes) {
    this.set("nftContract", Value.fromBytes(value));
  }

  get previousMerkleRoot(): Bytes {
    let value = this.get("previousMerkleRoot");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set previousMerkleRoot(value: Bytes) {
    this.set("previousMerkleRoot", Value.fromBytes(value));
  }

  get newMerkleRoot(): Bytes {
    let value = this.get("newMerkleRoot");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set newMerkleRoot(value: Bytes) {
    this.set("newMerkleRoot", Value.fromBytes(value));
  }

  get publicKeyURI(): Array<string> {
    let value = this.get("publicKeyURI");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toStringArray();
    }
  }

  set publicKeyURI(value: Array<string>) {
    this.set("publicKeyURI", Value.fromStringArray(value));
  }

  get allowListURI(): string {
    let value = this.get("allowListURI");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set allowListURI(value: string) {
    this.set("allowListURI", Value.fromString(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class AllowedFeeRecipientUpdated extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save AllowedFeeRecipientUpdated entity without an ID",
    );
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type AllowedFeeRecipientUpdated must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("AllowedFeeRecipientUpdated", id.toBytes().toHexString(), this);
    }
  }

  static loadInBlock(id: Bytes): AllowedFeeRecipientUpdated | null {
    return changetype<AllowedFeeRecipientUpdated | null>(
      store.get_in_block("AllowedFeeRecipientUpdated", id.toHexString()),
    );
  }

  static load(id: Bytes): AllowedFeeRecipientUpdated | null {
    return changetype<AllowedFeeRecipientUpdated | null>(
      store.get("AllowedFeeRecipientUpdated", id.toHexString()),
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get nftContract(): Bytes {
    let value = this.get("nftContract");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set nftContract(value: Bytes) {
    this.set("nftContract", Value.fromBytes(value));
  }

  get feeRecipient(): Bytes {
    let value = this.get("feeRecipient");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set feeRecipient(value: Bytes) {
    this.set("feeRecipient", Value.fromBytes(value));
  }

  get allowed(): boolean {
    let value = this.get("allowed");
    if (!value || value.kind == ValueKind.NULL) {
      return false;
    } else {
      return value.toBoolean();
    }
  }

  set allowed(value: boolean) {
    this.set("allowed", Value.fromBoolean(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class CreatorPayoutAddressUpdated extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save CreatorPayoutAddressUpdated entity without an ID",
    );
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type CreatorPayoutAddressUpdated must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set(
        "CreatorPayoutAddressUpdated",
        id.toBytes().toHexString(),
        this,
      );
    }
  }

  static loadInBlock(id: Bytes): CreatorPayoutAddressUpdated | null {
    return changetype<CreatorPayoutAddressUpdated | null>(
      store.get_in_block("CreatorPayoutAddressUpdated", id.toHexString()),
    );
  }

  static load(id: Bytes): CreatorPayoutAddressUpdated | null {
    return changetype<CreatorPayoutAddressUpdated | null>(
      store.get("CreatorPayoutAddressUpdated", id.toHexString()),
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get nftContract(): Bytes {
    let value = this.get("nftContract");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set nftContract(value: Bytes) {
    this.set("nftContract", Value.fromBytes(value));
  }

  get newPayoutAddress(): Bytes {
    let value = this.get("newPayoutAddress");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set newPayoutAddress(value: Bytes) {
    this.set("newPayoutAddress", Value.fromBytes(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class DropURIUpdated extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save DropURIUpdated entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type DropURIUpdated must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("DropURIUpdated", id.toBytes().toHexString(), this);
    }
  }

  static loadInBlock(id: Bytes): DropURIUpdated | null {
    return changetype<DropURIUpdated | null>(
      store.get_in_block("DropURIUpdated", id.toHexString()),
    );
  }

  static load(id: Bytes): DropURIUpdated | null {
    return changetype<DropURIUpdated | null>(
      store.get("DropURIUpdated", id.toHexString()),
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get nftContract(): Bytes {
    let value = this.get("nftContract");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set nftContract(value: Bytes) {
    this.set("nftContract", Value.fromBytes(value));
  }

  get newDropURI(): string {
    let value = this.get("newDropURI");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set newDropURI(value: string) {
    this.set("newDropURI", Value.fromString(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class PayerUpdated extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save PayerUpdated entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type PayerUpdated must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("PayerUpdated", id.toBytes().toHexString(), this);
    }
  }

  static loadInBlock(id: Bytes): PayerUpdated | null {
    return changetype<PayerUpdated | null>(
      store.get_in_block("PayerUpdated", id.toHexString()),
    );
  }

  static load(id: Bytes): PayerUpdated | null {
    return changetype<PayerUpdated | null>(
      store.get("PayerUpdated", id.toHexString()),
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get nftContract(): Bytes {
    let value = this.get("nftContract");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set nftContract(value: Bytes) {
    this.set("nftContract", Value.fromBytes(value));
  }

  get payer(): Bytes {
    let value = this.get("payer");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set payer(value: Bytes) {
    this.set("payer", Value.fromBytes(value));
  }

  get allowed(): boolean {
    let value = this.get("allowed");
    if (!value || value.kind == ValueKind.NULL) {
      return false;
    } else {
      return value.toBoolean();
    }
  }

  set allowed(value: boolean) {
    this.set("allowed", Value.fromBoolean(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class PublicDropUpdated extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save PublicDropUpdated entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type PublicDropUpdated must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("PublicDropUpdated", id.toBytes().toHexString(), this);
    }
  }

  static loadInBlock(id: Bytes): PublicDropUpdated | null {
    return changetype<PublicDropUpdated | null>(
      store.get_in_block("PublicDropUpdated", id.toHexString()),
    );
  }

  static load(id: Bytes): PublicDropUpdated | null {
    return changetype<PublicDropUpdated | null>(
      store.get("PublicDropUpdated", id.toHexString()),
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get nftContract(): Bytes {
    let value = this.get("nftContract");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set nftContract(value: Bytes) {
    this.set("nftContract", Value.fromBytes(value));
  }

  get publicDrop_mintPrice(): BigInt {
    let value = this.get("publicDrop_mintPrice");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set publicDrop_mintPrice(value: BigInt) {
    this.set("publicDrop_mintPrice", Value.fromBigInt(value));
  }

  get publicDrop_startTime(): BigInt {
    let value = this.get("publicDrop_startTime");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set publicDrop_startTime(value: BigInt) {
    this.set("publicDrop_startTime", Value.fromBigInt(value));
  }

  get publicDrop_endTime(): BigInt {
    let value = this.get("publicDrop_endTime");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set publicDrop_endTime(value: BigInt) {
    this.set("publicDrop_endTime", Value.fromBigInt(value));
  }

  get publicDrop_maxTotalMintableByWallet(): i32 {
    let value = this.get("publicDrop_maxTotalMintableByWallet");
    if (!value || value.kind == ValueKind.NULL) {
      return 0;
    } else {
      return value.toI32();
    }
  }

  set publicDrop_maxTotalMintableByWallet(value: i32) {
    this.set("publicDrop_maxTotalMintableByWallet", Value.fromI32(value));
  }

  get publicDrop_feeBps(): i32 {
    let value = this.get("publicDrop_feeBps");
    if (!value || value.kind == ValueKind.NULL) {
      return 0;
    } else {
      return value.toI32();
    }
  }

  set publicDrop_feeBps(value: i32) {
    this.set("publicDrop_feeBps", Value.fromI32(value));
  }

  get publicDrop_restrictFeeRecipients(): boolean {
    let value = this.get("publicDrop_restrictFeeRecipients");
    if (!value || value.kind == ValueKind.NULL) {
      return false;
    } else {
      return value.toBoolean();
    }
  }

  set publicDrop_restrictFeeRecipients(value: boolean) {
    this.set("publicDrop_restrictFeeRecipients", Value.fromBoolean(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class ShibaDropMint extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save ShibaDropMint entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type ShibaDropMint must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("ShibaDropMint", id.toBytes().toHexString(), this);
    }
  }

  static loadInBlock(id: Bytes): ShibaDropMint | null {
    return changetype<ShibaDropMint | null>(
      store.get_in_block("ShibaDropMint", id.toHexString()),
    );
  }

  static load(id: Bytes): ShibaDropMint | null {
    return changetype<ShibaDropMint | null>(
      store.get("ShibaDropMint", id.toHexString()),
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get nftContract(): Bytes {
    let value = this.get("nftContract");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set nftContract(value: Bytes) {
    this.set("nftContract", Value.fromBytes(value));
  }

  get minter(): Bytes {
    let value = this.get("minter");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set minter(value: Bytes) {
    this.set("minter", Value.fromBytes(value));
  }

  get feeRecipient(): Bytes {
    let value = this.get("feeRecipient");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set feeRecipient(value: Bytes) {
    this.set("feeRecipient", Value.fromBytes(value));
  }

  get payer(): Bytes {
    let value = this.get("payer");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set payer(value: Bytes) {
    this.set("payer", Value.fromBytes(value));
  }

  get quantityMinted(): BigInt {
    let value = this.get("quantityMinted");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set quantityMinted(value: BigInt) {
    this.set("quantityMinted", Value.fromBigInt(value));
  }

  get unitMintPrice(): BigInt {
    let value = this.get("unitMintPrice");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set unitMintPrice(value: BigInt) {
    this.set("unitMintPrice", Value.fromBigInt(value));
  }

  get feeBps(): BigInt {
    let value = this.get("feeBps");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set feeBps(value: BigInt) {
    this.set("feeBps", Value.fromBigInt(value));
  }

  get dropStageIndex(): BigInt {
    let value = this.get("dropStageIndex");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set dropStageIndex(value: BigInt) {
    this.set("dropStageIndex", Value.fromBigInt(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class SignedMintValidationParamsUpdated extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save SignedMintValidationParamsUpdated entity without an ID",
    );
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type SignedMintValidationParamsUpdated must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set(
        "SignedMintValidationParamsUpdated",
        id.toBytes().toHexString(),
        this,
      );
    }
  }

  static loadInBlock(id: Bytes): SignedMintValidationParamsUpdated | null {
    return changetype<SignedMintValidationParamsUpdated | null>(
      store.get_in_block("SignedMintValidationParamsUpdated", id.toHexString()),
    );
  }

  static load(id: Bytes): SignedMintValidationParamsUpdated | null {
    return changetype<SignedMintValidationParamsUpdated | null>(
      store.get("SignedMintValidationParamsUpdated", id.toHexString()),
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get nftContract(): Bytes {
    let value = this.get("nftContract");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set nftContract(value: Bytes) {
    this.set("nftContract", Value.fromBytes(value));
  }

  get signer(): Bytes {
    let value = this.get("signer");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set signer(value: Bytes) {
    this.set("signer", Value.fromBytes(value));
  }

  get signedMintValidationParams_minMintPrice(): BigInt {
    let value = this.get("signedMintValidationParams_minMintPrice");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set signedMintValidationParams_minMintPrice(value: BigInt) {
    this.set(
      "signedMintValidationParams_minMintPrice",
      Value.fromBigInt(value),
    );
  }

  get signedMintValidationParams_maxMaxTotalMintableByWallet(): i32 {
    let value = this.get(
      "signedMintValidationParams_maxMaxTotalMintableByWallet",
    );
    if (!value || value.kind == ValueKind.NULL) {
      return 0;
    } else {
      return value.toI32();
    }
  }

  set signedMintValidationParams_maxMaxTotalMintableByWallet(value: i32) {
    this.set(
      "signedMintValidationParams_maxMaxTotalMintableByWallet",
      Value.fromI32(value),
    );
  }

  get signedMintValidationParams_minStartTime(): BigInt {
    let value = this.get("signedMintValidationParams_minStartTime");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set signedMintValidationParams_minStartTime(value: BigInt) {
    this.set(
      "signedMintValidationParams_minStartTime",
      Value.fromBigInt(value),
    );
  }

  get signedMintValidationParams_maxEndTime(): BigInt {
    let value = this.get("signedMintValidationParams_maxEndTime");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set signedMintValidationParams_maxEndTime(value: BigInt) {
    this.set("signedMintValidationParams_maxEndTime", Value.fromBigInt(value));
  }

  get signedMintValidationParams_maxMaxTokenSupplyForStage(): BigInt {
    let value = this.get(
      "signedMintValidationParams_maxMaxTokenSupplyForStage",
    );
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set signedMintValidationParams_maxMaxTokenSupplyForStage(value: BigInt) {
    this.set(
      "signedMintValidationParams_maxMaxTokenSupplyForStage",
      Value.fromBigInt(value),
    );
  }

  get signedMintValidationParams_minFeeBps(): i32 {
    let value = this.get("signedMintValidationParams_minFeeBps");
    if (!value || value.kind == ValueKind.NULL) {
      return 0;
    } else {
      return value.toI32();
    }
  }

  set signedMintValidationParams_minFeeBps(value: i32) {
    this.set("signedMintValidationParams_minFeeBps", Value.fromI32(value));
  }

  get signedMintValidationParams_maxFeeBps(): i32 {
    let value = this.get("signedMintValidationParams_maxFeeBps");
    if (!value || value.kind == ValueKind.NULL) {
      return 0;
    } else {
      return value.toI32();
    }
  }

  set signedMintValidationParams_maxFeeBps(value: i32) {
    this.set("signedMintValidationParams_maxFeeBps", Value.fromI32(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class TokenGatedDropStageUpdated extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save TokenGatedDropStageUpdated entity without an ID",
    );
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type TokenGatedDropStageUpdated must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("TokenGatedDropStageUpdated", id.toBytes().toHexString(), this);
    }
  }

  static loadInBlock(id: Bytes): TokenGatedDropStageUpdated | null {
    return changetype<TokenGatedDropStageUpdated | null>(
      store.get_in_block("TokenGatedDropStageUpdated", id.toHexString()),
    );
  }

  static load(id: Bytes): TokenGatedDropStageUpdated | null {
    return changetype<TokenGatedDropStageUpdated | null>(
      store.get("TokenGatedDropStageUpdated", id.toHexString()),
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get nftContract(): Bytes {
    let value = this.get("nftContract");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set nftContract(value: Bytes) {
    this.set("nftContract", Value.fromBytes(value));
  }

  get allowedNftToken(): Bytes {
    let value = this.get("allowedNftToken");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set allowedNftToken(value: Bytes) {
    this.set("allowedNftToken", Value.fromBytes(value));
  }

  get dropStage_mintPrice(): BigInt {
    let value = this.get("dropStage_mintPrice");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set dropStage_mintPrice(value: BigInt) {
    this.set("dropStage_mintPrice", Value.fromBigInt(value));
  }

  get dropStage_maxTotalMintableByWallet(): i32 {
    let value = this.get("dropStage_maxTotalMintableByWallet");
    if (!value || value.kind == ValueKind.NULL) {
      return 0;
    } else {
      return value.toI32();
    }
  }

  set dropStage_maxTotalMintableByWallet(value: i32) {
    this.set("dropStage_maxTotalMintableByWallet", Value.fromI32(value));
  }

  get dropStage_startTime(): BigInt {
    let value = this.get("dropStage_startTime");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set dropStage_startTime(value: BigInt) {
    this.set("dropStage_startTime", Value.fromBigInt(value));
  }

  get dropStage_endTime(): BigInt {
    let value = this.get("dropStage_endTime");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set dropStage_endTime(value: BigInt) {
    this.set("dropStage_endTime", Value.fromBigInt(value));
  }

  get dropStage_dropStageIndex(): i32 {
    let value = this.get("dropStage_dropStageIndex");
    if (!value || value.kind == ValueKind.NULL) {
      return 0;
    } else {
      return value.toI32();
    }
  }

  set dropStage_dropStageIndex(value: i32) {
    this.set("dropStage_dropStageIndex", Value.fromI32(value));
  }

  get dropStage_maxTokenSupplyForStage(): BigInt {
    let value = this.get("dropStage_maxTokenSupplyForStage");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set dropStage_maxTokenSupplyForStage(value: BigInt) {
    this.set("dropStage_maxTokenSupplyForStage", Value.fromBigInt(value));
  }

  get dropStage_feeBps(): i32 {
    let value = this.get("dropStage_feeBps");
    if (!value || value.kind == ValueKind.NULL) {
      return 0;
    } else {
      return value.toI32();
    }
  }

  set dropStage_feeBps(value: i32) {
    this.set("dropStage_feeBps", Value.fromI32(value));
  }

  get dropStage_restrictFeeRecipients(): boolean {
    let value = this.get("dropStage_restrictFeeRecipients");
    if (!value || value.kind == ValueKind.NULL) {
      return false;
    } else {
      return value.toBoolean();
    }
  }

  set dropStage_restrictFeeRecipients(value: boolean) {
    this.set("dropStage_restrictFeeRecipients", Value.fromBoolean(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class NewInstance extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save NewInstance entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type NewInstance must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("NewInstance", id.toBytes().toHexString(), this);
    }
  }

  static loadInBlock(id: Bytes): NewInstance | null {
    return changetype<NewInstance | null>(
      store.get_in_block("NewInstance", id.toHexString()),
    );
  }

  static load(id: Bytes): NewInstance | null {
    return changetype<NewInstance | null>(
      store.get("NewInstance", id.toHexString()),
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get instance(): Bytes {
    let value = this.get("instance");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set instance(value: Bytes) {
    this.set("instance", Value.fromBytes(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }

  get name(): string {
    let value = this.get("name");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set name(value: string) {
    this.set("name", Value.fromString(value));
  }

  get symbol(): string {
    let value = this.get("symbol");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set symbol(value: string) {
    this.set("symbol", Value.fromString(value));
  }
}
